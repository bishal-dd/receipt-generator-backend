package encryptedReceipt

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	"github.com/bishal-dd/receipt-generator-backend/graph/model"
	"github.com/bishal-dd/receipt-generator-backend/helper/contextUtil"
	"github.com/bishal-dd/receipt-generator-backend/helper/paginationUtil"
)

func (r *EncryptedReceiptResolver) EncryptedReceipts(ctx context.Context, first *int, after *string) (*model.EncryptedReceiptConnection, error) {
	userId, err := contextUtil.UserIdFromContext(ctx)
	if err != nil {
		return nil, err
	}

	offset, limit, err := paginationUtil.CalculatePagination(first, after)
	if err != nil {
		return nil, err
	}

	totalEncryptedReceipts, err := r.CountTotalEncryptedReceipts()
	if err != nil {
		return nil, err
	}

	receipts, err := r.FetchEncryptedReceiptsFromDB(ctx, offset, limit, userId)
	if err != nil {
		return nil, err
	}
	// üîê Decrypt each receipt
	for _, receipt := range receipts {
		err := r.decryptReceipt(receipt)
		if err != nil {
			// Optionally skip or return error
			return nil, fmt.Errorf("failed to decrypt receipt %s: %w", receipt.ID, err)
		}
	}

	connection := paginationUtil.CreateConnection(receipts, totalEncryptedReceipts, offset)

	return &model.EncryptedReceiptConnection{
		Edges:      convertEdges(connection.Edges),
		PageInfo:   (*model.PageInfo)(connection.PageInfo),
		TotalCount: connection.TotalCount,
	}, nil
}

func (r *EncryptedReceiptResolver) EncryptedReceipt(ctx context.Context, id string) (*model.Receipt, error) {
	newEncryptedReceipt, err := r.GetEncryptedReceiptFromDB(ctx, id)
	if err != nil {
		return nil, err
	}

	return newEncryptedReceipt, nil
}

func (r *EncryptedReceiptResolver) SearchEncryptedReceipts(ctx context.Context, page int, year *int, date *string, dateRange []string) (*model.SearchEncryptedReceipt, error) {
	userId, err := contextUtil.UserIdFromContext(ctx)
	if err != nil {
		return nil, err
	}

	if err := searchDataRangeValidation(dateRange); err != nil {
		return nil, err
	}

	const pageSize = 10
	offset := (page - 1) * pageSize

	var (
		receipts   []model.EncryptedReceipt
		totalCount int64
		foundCount int64
	)

	// 1. Count total receipts for user (no filters)
	if err := r.db.Model(&model.EncryptedReceipt{}).
		Where("user_id = ?", userId).
		Count(&totalCount).Error; err != nil {
		return nil, err
	}

	// 2. Build filtered query
	query := r.db.Where("user_id = ?", userId)

	if year != nil {
		query = query.Where("EXTRACT(YEAR FROM date) = ?", *year)
	}

	if date != nil {
		query = query.Where("date = ?", *date)
	}

	if len(dateRange) == 2 {
		query = query.Where("date BETWEEN ? AND ?", dateRange[0], dateRange[1])
	}

	// 3. Count found receipts (after applying filters)
	if err := query.Model(&model.EncryptedReceipt{}).Count(&foundCount).Error; err != nil {
		return nil, err
	}

	// 4. Fetch paginated receipts
	if err := query.Order("date DESC").Offset(offset).Limit(pageSize).Find(&receipts).Error; err != nil {
		return nil, err
	}

	receiptsPtr := []*model.EncryptedReceipt{}
	for _, receipt := range receipts {
		receiptsPtr = append(receiptsPtr, &receipt)
	}

	return &model.SearchEncryptedReceipt{
		Receipts:   receiptsPtr,
		TotalCount: int(totalCount),
		FoundCount: int(foundCount),
	}, nil
}
