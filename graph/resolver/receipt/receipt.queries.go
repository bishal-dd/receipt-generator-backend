package receipt

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"time"

	"github.com/bishal-dd/receipt-generator-backend/graph/model"
	"github.com/bishal-dd/receipt-generator-backend/helper"
	"github.com/bishal-dd/receipt-generator-backend/helper/contextUtil"
	"github.com/bishal-dd/receipt-generator-backend/helper/pagination"
	"github.com/bishal-dd/receipt-generator-backend/helper/redisUtil"
	"github.com/redis/go-redis/v9"
)


func (r *ReceiptResolver) Receipts(ctx context.Context, first *int, after *string) (*model.ReceiptConnection, error) {
    userId, err := contextUtil.UserIdFromContext(ctx)
    if err != nil {
        return nil, err
    }
    var receipts []*model.Receipt
    var totalReceipts int64
    limit := pagination.Limit(first)
	offset, err := pagination.Offset(after)
	if err != nil {
		return nil, err 
	} 
    if err := r.db.Model(&model.Receipt{}).Count(&totalReceipts).Error; err != nil {
        return nil, err
    }

    pageCacheKey := fmt.Sprintf("%s:%d:%d:%s", ReceiptsKey, offset, limit,userId)
    receiptsJSON, err := r.redis.Get(ctx, pageCacheKey).Result()
    if err == redis.Nil {
        if err := r.db.Offset(offset).Limit(limit).Find(&receipts).Error; err != nil {
            return nil, err
        }
        if err = r.redis.SAdd(ctx, ReceiptsPageGroupKey, pageCacheKey).Err(); err != nil {
            return nil, err
        }
        if err := r.redis.Expire(ctx, ReceiptsPageGroupKey, 600*time.Second).Err(); err != nil {
            return nil, err
        }
        if err = redisUtil.CacheResult(r.redis, ctx, pageCacheKey, receipts, 10); err != nil {
            return nil, err
        }
    } else if err != nil {
        return nil, err
    } else {
        if err := helper.Unmarshal([]byte(receiptsJSON), &receipts); err != nil {
            return nil, err
        }
    }
    if receipts == nil {
        receipts = []*model.Receipt{}
    }
    
    edges, end := Edges(offset, limit, receipts)
    pageInfo := PageInfo(edges, totalReceipts, end, offset )
    return &model.ReceiptConnection{
        Edges:      edges,
        PageInfo:   pageInfo,
        TotalCount: int(totalReceipts),
    }, nil
}


func (r *ReceiptResolver) Receipt(ctx context.Context, id string) (*model.Receipt, error) {
	 cacheKey := ReceiptKey + id
	 receiptJSON, err := r.redis.Get(ctx, cacheKey).Result()
	 var receipt *model.Receipt
	 if err == redis.Nil {
		if err := r.db.Where("id = ?", id).First(&receipt).Error; err != nil {
			return nil, err
		}
		if err = redisUtil.CacheResult(r.redis, ctx, cacheKey, receipt, 10); err != nil {
			return nil, err
		}
        return receipt, nil
    } else if err != nil {
        return nil, err
    }
	
	if err := helper.Unmarshal([]byte(receiptJSON), &receipt); err != nil {
		return nil, err
	}	 
    
	 return receipt, nil
}
