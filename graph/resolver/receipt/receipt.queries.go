package receipt

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	"github.com/bishal-dd/receipt-generator-backend/graph/model"
	"github.com/bishal-dd/receipt-generator-backend/helper/contextUtil"
	"github.com/bishal-dd/receipt-generator-backend/helper/paginationUtil"
)

func (r *ReceiptResolver) Receipts(ctx context.Context, first *int, after *string) (*model.ReceiptConnection, error) {
	userId, err := contextUtil.UserIdFromContext(ctx)
	if err != nil {
		return nil, err
	}

	offset, limit, err := paginationUtil.CalculatePagination(first, after)
	if err != nil {
		return nil, err
	}
	totalReceipts, err := r.CountTotalReceipts()
	if err != nil {
		return nil, err
	}
	receipts, err := r.FetchReceiptsFromDB(ctx, offset, limit, userId)
	if err != nil {
		return nil, err
	}

	connection := paginationUtil.CreateConnection(receipts, totalReceipts, offset)

	return &model.ReceiptConnection{
		Edges:      convertEdges(connection.Edges),
		PageInfo:   (*model.PageInfo)(connection.PageInfo),
		TotalCount: connection.TotalCount,
	}, nil
}

func (r *ReceiptResolver) Receipt(ctx context.Context, id string) (*model.Receipt, error) {
	newReceipt, err := r.GetReceiptFromDB(ctx, id)
	if err != nil {
		return nil, err
	}

	return newReceipt, nil
}

func (r *ReceiptResolver) SearchReceipts(ctx context.Context, page int, year *int, date *string, dateRange []string) (*model.SearchReceipt, error) {
	userId, err := contextUtil.UserIdFromContext(ctx)
	if err != nil {
		return nil, err
	}

	if err := searchDataRangeValidation(dateRange); err != nil {
		return nil, err
	}

	const pageSize = 10
	offset := (page - 1) * pageSize

	var (
		encryptedReceipts []model.EncryptedReceipt
		totalCount        int64
		foundCount        int64
	)

	// Count total receipts
	if err := r.db.Model(&model.EncryptedReceipt{}).
		Where("user_id = ?", userId).
		Count(&totalCount).Error; err != nil {
		return nil, err
	}

	// Apply filters
	query := r.db.Where("user_id = ?", userId)

	if year != nil {
		query = query.Where("EXTRACT(YEAR FROM date) = ?", *year)
	}
	if date != nil {
		query = query.Where("date = ?", *date)
	}
	if len(dateRange) == 2 {
		query = query.Where("date BETWEEN ? AND ?", dateRange[0], dateRange[1])
	}

	// Count found receipts after filters
	if err := query.Model(&model.EncryptedReceipt{}).Count(&foundCount).Error; err != nil {
		return nil, err
	}

	// Fetch paginated encrypted receipts
	if err := query.Order("date DESC").Offset(offset).Limit(pageSize).Find(&encryptedReceipts).Error; err != nil {
		return nil, err
	}

	var receiptsPtr []*model.Receipt

	for _, enc := range encryptedReceipts {
		// Decrypt each encrypted receipt
		if err := r.decryptReceipt(&enc); err != nil {
			return nil, fmt.Errorf("failed to decrypt receipt %s: %w", enc.ID, err)
		}

		receipt, err := EncryptedReceiptToReceipt(&enc)
		if err != nil {
			return nil, fmt.Errorf("failed to convert encrypted receipt %s to receipt: %w", enc.ID, err)
		}
		receiptsPtr = append(receiptsPtr, receipt)
	}

	return &model.SearchReceipt{
		Receipts:   receiptsPtr,
		TotalCount: int(totalCount),
		FoundCount: int(foundCount),
	}, nil
}
